Chapter 10 Security improvements
    
    Serão feitas atualizações para manter os dados em trânsito seguros e fazer com que o
    servidor é mais capaz de lidar com alguns tipos comuns de ataques de negação de serviço.

    10.1 Generating a self-signed TLS certificate

        HTTPS é basicamente HTTP transferido através de uma conexão TLS(Transport Layer Security).
        Os dados são criptografados e assinados, garantindo a privacidade e segurança em trânsito.

        Antes de configurar a aplicação para usar HTTPS é preciso gerar um certificado TLS.
        A maneira mais simples de fazer isso em desenvolvimento é através de self-signe certificate.
        Um self-signed certificate é a mesma coisa que um certificado TLS normal, exceto que ele não é
        assinado criptograficamete por uma autoridade certificadora confiável(trusted certificate authority).
        O pacote crypto/tls na biblioteca padrão do Go fornece a ferramenta generate_cert.go que facilita a criação do certificado.

        Criar um diretório chamado tls no projeto.

        Para executar generate_cert.go é preciso saber o local de instação do Go.
        Geralmente este arquivo fica localizado em /usr/local/go/src/crypto/tls.

            mkdir tls
            cd tls
            go run /bin/go/src/crypto/tls/generate_cert.go --rsa-bits=2048 --host=localhost
            # go run ./generate_cert.go --rsa-bits=2048 --host=localhost
        
            1 - gera um key-pair RSA 2048, que são uma chave pública e uma chave privada criptograficamente seguras.
            2 - armazena a chave privada em key.pem, então gera um self-signed certificate para localhost contendo
                a chave pública e o armazena em cert.pem.
    
    10.2 Running a HTTPS server
        Tendo o self-signed certificate(cert.pem) e a chave privada correspondente fica fácil iniciar o servidor HTTPS.
        Mudar de  srv.ListenAndServe() para  srv.ListenAndServeTLS() em main.go.

            err = srv.ListenAndServeTLS("./tls/cert.pem", "./tls/key.pem")
    
    10.3 Configuring HTTPS settings
        
            É recomendado limitar as 'elliptc curves' que podem ser usadas durante o TLS handshake.
            O Go suporta diferentes 'elliptc curves', mas a partir do go 1.18 apenas tls.CurveP256 e tls.X25519
            tem implementação em assembly.
            As outras 'elliptc curves' são CPU intensive, omiti-las ajuda a garantir que o servidor conseguirá performar sob altas cargas.

            Criar uma struct tls.Config contendo as configurações não default de TLS e adiciona-la ao campo TLSConfig do http.Server.

        Additional information

            TLS versions
                As versões do TLS são definidas como constantes no pacote crypt/tls e o HTTP Server suporta TLS 1.0 a 1.3.
                É possível configurar a versão minima e versão máxima do TLS através dos campos tls.Config.MinVersion e  tls.Config.MaxVersion.

                tlsConfig := &tls.Config{
                    MinVersion: tls.VersionTLS12,
                    MaxVersion: tls.VersionTLS12,
                }
    
    10.4 Connection timeouts

        Melhorando a resiliencia da aplicação adicionando configurações de timeout:
            srv := &http.Server{
                // Add Idle, Read and Write timeouts to the server.
                IdleTimeout:  time.Minute,
                ReadTimeout:  5 * time.Second,
                WriteTimeout: 10 * time.Second,
            }
        Essas configurações são validas para o servidor, ou seja, são aplicadas a todas as requisições recebidas.

        The IdleTimeout setting
            Por padrão o Go habilita keep-alives em todas as conexões, isso ajuda a diminuir a latencia porque
            o cliente consegue usar a mesma conexão para múltiplas requisições sem precisar refazer o TLS handshake.

            Conexões keep-alive são encerradas depois de alguns minutos.
            Não há como aumentar esse tempo, mas é possível diminui-lo através do IdleTimeout.
        
        The ReadTimeout setting
            Se os Headers ou Body da requisição ainda estiverem sendo lidos após 5 segundos(ReadTimeout) depois
            que a requisição foi aceita pela primeira vez, o Go fechara a conexão.

            Um ReadTimeout baixo evita ataques de clientes lentos Slowloris(https://en.wikipedia.org/wiki/Slowloris_(computer_security)).
            Estes ataques podem manter conexões abertas por muito tempo enviado requisições HTTP incompletas.

            Se ReadTimeout for definido e IdleTimeout for deixado como está, então IdleTimeout usará a mesma configuração de ReadTimeout.
        
        The WriteTimeout setting
            The WriteTimeout setting will close the underlying connection if
            our server attempts to write to the connection after a given period.
                -   For HTTP connections, if some data is written to the connection more than 10 seconds after the read of
                    the request header finished, Go will close the underlying connection instead of writing the data.
                
                -   For HTTPS connections, if some data is written to the connection more than 10 seconds after
                    the request is first accepted, Go will close the underlying connection instead of writing the data.
                    This means that if you’re using HTTPS it’s sensible to set WriteTimeout to a value greater than ReadTimeout.

            It’s important to bear in mind that writes made by a handler are buffered and
            written to the connection as one when the handler returns.
            The idea of WriteTimeout is generally not to prevent long-running handlers,
            but to prevent the data that the handler returns from taking too long to write.
