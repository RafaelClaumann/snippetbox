####
#### 1
#### 14.2 Testing HTTP handlers and middleware
####
{
    Seja esse o handler health:
        func health(w http.ResponseWriter, r *http.Request) { }

    Essa chamada funciona(1):
        var rw *httptest.ResponseRecorder = &httptest.ResponseRecorder{}
        health(rw, nil)
    
    Essa chamada não funciona(2):
        var rw1 httptest.ResponseRecorder = httptest.ResponseRecorder{}
        health(rw1, nil)

    Porque isso acontece se health() nao espera que ResponseWritter seja um ponteiro?

        - A interface http.ResponseWriter define os métodos que um tipo deve implementar
            para ser considerado um ResponseWriter.

        - *httptest.ResponseRecorder (ponteiro) implementa http.ResponseWriter,
            permitindo que ele seja usado onde http.ResponseWriter é esperado.
        
        - httptest.ResponseRecorder (valor) não implementa http.ResponseWriter,
            causando um erro de compilação se usado diretamente.
        
        - Use httptest.NewRecorder() para criar um ResponseRecorder corretamente inicializado que funciona como esperado.

        type ResponseWriter interface {
            Header() Header
            Write([]byte) (int, error)
            WriteHeader(statusCode int)
        }

        type ResponseRecorder struct {}
        func (rw *ResponseRecorder) Header() http.Header { }
        func (rw *ResponseRecorder) writeHeader(b []byte, str string) { }
        func (rw *ResponseRecorder) Write(buf []byte) (int, error) { }

        Para que a segunda chamada também funcionasse, ResponseRecorder teria que ser assim:

            type ResponseRecorder struct {}
            func (rw *ResponseRecorder) Header() http.Header { }
            func (rw *ResponseRecorder) writeHeader(b []byte, str string) { }
            func (rw *ResponseRecorder) Write(buf []byte) (int, error) { }
            
            func (rw ResponseRecorder) Header() http.Header { }
            func (rw ResponseRecorder) writeHeader(b []byte, str string) { }
            func (rw ResponseRecorder) Write(buf []byte) (int, error) { }
}

####
#### 2
#### 14.3 End-to-end testing
####
{
    Porque algumas funções de testutils_test.go recebem t *testing.T como argumento?
    Sendo que 't' não é usado para nada

        func newTestApplication(t *testing.T) *application {
            return &application{
                errorLog: log.New(io.Discard, "", 0),
                infoLog:  log.New(io.Discard, "", 0),
            }
        }
    
    Resposta do ChatGPT.

        O parâmetro t *testing.T na assinatura da função newTestApplication é significativo, especialmente
        se você estiver trabalhando com o framework de teste do Go.

        Em Go, ao escrever testes usando o pacote testing da biblioteca padrão, você geralmenteusa um objeto do tipo
        testing.T para relatar falhas nos testes e mensagens de log durante a execução dos testes.

        No contexto da sua função newTestApplication, parece que o parâmetro t *testing.T não é diretamente utilizado dentro
        do corpo da função. Provavelmente está incluído para consistência com a assinatura típica de funções relacionadas a
        testes em Go, especialmente se você planeja expandir a funcionalidade dessa função posteriormente para incluir
        configuração adicional específica de teste ou asserções.

        Portanto, embora o parâmetro t *testing.T não desempenhe um papel direto na funcionalidade de newTestApplication
        conforme está, sua presença na assinatura da função sugere que essa função deve ser usada no contexto de testes,
        e ela está alinhada com as convenções de teste do Go.
}
