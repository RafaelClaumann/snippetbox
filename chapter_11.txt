Chapter 11 User authentication
    
    Adicionar autenticação a aplicação:
        - Apenas usuários registrados e logados conseguirão criar snippets.
        - Usuários não logados conseguirão ver os snippets.
        - Usuários não registrados conseguirão se registrar.
    
    Passo a passo:
        - Usuários poderão se registrar em '/user/signup' com nome, email e senha.
          Uma nova tabela(users) será criada para armazenar os usuários.

        - Usuários farão o login em '/user/login' com email e senha.
    
        - Verificar se usuário e senha são compatíveis com os valores recuperados do banco de dados.
          Se forem compatíveis, o usuário será autenticado e a chave 'authenticatedUserID' será adicionada ao 'session data'.

        - As requisições subsequentes serão verificadas através da chave 'authenticatedUserID'.
          Se 'authenticatedUserID' existir, significa que o usuário logou com sucesso, essa chave será monitorada a sessão expirar.
          Se 'authenticatedUserID' não existir, significa que o usuário não está autenticado.

    11.1 Routes setup

            GET     /user/signup    userSignup      Display a HTML form for signing up a new user
            POST    /user/signup    userSignupPost  Create a new user
            GET     /user/login     userLogin       Display a HTML form for logging in a user
            POST    /user/login     userLoginPost   Authenticate and login the user
            POST    /user/logout    userLogoutPost  Logout the user

        Adicionar a pre-implementação das novas rotas no arquivo handlers.go.

            func (app *application) userSignup(w http.ResponseWriter, r *http.Request)
            func (app *application) userSignupPost(w http.ResponseWriter, r *http.Request)
            func (app *application) userLogin(w http.ResponseWriter, r *http.Request)
            func (app *application) userLoginPost(w http.ResponseWriter, r *http.Request)
            func (app *application) userLogoutPost(w http.ResponseWriter, r *http.Request)

        Configurar as os handlers em routers.go.
            router.Handler(http.MethodGet, "/user/signup", dynamic.ThenFunc(app.userSignup))
            router.Handler(http.MethodPost, "/user/signup", dynamic.ThenFunc(app.userSignupPost))
            router.Handler(http.MethodGet, "/user/login", dynamic.ThenFunc(app.userLogin))
            router.Handler(http.MethodPost, "/user/login", dynamic.ThenFunc(app.userLoginPost))
            router.Handler(http.MethodPost, "/user/logout", dynamic.ThenFunc(app.userLogoutPost))

        Atualizar o nav.tmpl com uma nova <div> para exibir os botões Singup, Login e Logout':
                <div>
                    <a href='/user/signup'>Signup</a>
                    <a href='/user/login'>Login</a>
                    <form action='/user/logout' method='POST'>
                        <button>Logout</button>
                    </form>
                </div>
    
    11.2 Creating a users model

        Criar a tabela no banco de dados e o modelo(repository) para acessa-la.

                USE snippetbox;

                CREATE TABLE users (
                    id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
                    name VARCHAR(255) NOT NULL,
                    email VARCHAR(255) NOT NULL,
                    hashed_password CHAR(60) NOT NULL,
                    created DATETIME NOT NULL
                );

                ALTER TABLE users ADD CONSTRAINT users_uc_email UNIQUE (email);
            
            A constraint users_uc_email garante que não existirão dois usuários com o mesmo e-mail.
    
        Building the model in Go
            Definir novos erros no arquivo models/errors.go.
                var ErrInvalidCredentials = errors.New("models: invalid credentials")
                var ErrDuplicateEmail = errors.New("models: duplicate email")
            
            Criar um novo arquivo models/users.go.
            
            Adicionar um campo users do tipo *models.UserModel na struct application em main.go.

    11.3 User signup and password encryption

        É preciso permitir que os usuários registrem suas contas(singup).
        Criar um novo arquivo ui/html/pages/signup.tmpl.
        Inserir a struct userSignupForm em handlers.go e atualizar o handler userSignup para que signup.tmpl seja exibido.

            templates.go
                type templateData struct {
                    Form        any
                }

            helpers.go
                func (app *application) newTemplateData(r *http.Request) *templateData {
                    return &templateData{
                        CurrentYear: time.Now().Year(),
                    }
                }

            validator.go 
                type Validator struct {
                    FieldErrors map[string]string
                }

            handlers.go
                type userSignupForm struct {
                    validator.Validator
                }

                func (app *application) userSignup(w http.ResponseWriter, r *http.Request) {
                    data := app.newTemplateData(r)
                    data.Form = userSignupForm{}

                    app.render(w, http.StatusOK, "signup.tmpl", data)
                }

            A chamada a app.newTemplateData(r) cria um novo templateData e o armazena na variável data.
            O campo Form deste template data recebe um 'userSignupForm'.
            O 'userSignupForm' encorpora(embed) a struct 'Validator' que contém o campo 'FieldErrors'.
            É possível acessar 'FieldErrors' a partir de 'userSignupForm': data.Form.FieldErrors.
            O template signup.tmpl recebe 'userSignupForm' e por isso consegue acessar data.Form.FieldErrors.
    
        Validating the user input
            Os dados submetidos em signup.tmpl serão processados no handler userSignupPost.
            É preciso validar os dados para garantir que são 'sane' antes de inseri-los no banco de dados.
                1 - Garantir que name, email e password não são blank
                2 - 'Sanity' check no formato do email
                3 - Garantir que o password tenha mais do que 8 caracteres
                4 - Certifique-se de que o endereço de e-mail ainda não esteja em uso
            
            Criar dois novos validadores e uma regex para e-mails em Validator.go.
                - MinChars()
                - Matches()
                - var EmailRX = regexp.MustCompile(...)
            
                A regex usada é recomendada pela W3C e Web Hypertext Application Technology Working Group.
                https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
                https://www.w3.org/TR/2016/REC-html51-20161101/sec-forms.html#email-state-typeemail
            
            Adicionar código em userSignupPost para processar os dados do form.

            Tudo que restou foi validar que o e-mail inserido no formulário ainda não está em uso.
            A constraint UNIQUE na coluna email da tabela users garante que o mesmo email não será usado mais de uma vez.
            Do ponto de vista da regra de negócio e integridade de dados está tudo OK.
            Mas, o problema é, como comunicar para o cliente que o e-mail já está em uso?
            Isto será resolvido no final do capitulo

        A brief introduction to bcrypt
            É uma desejavel que os passwords armazenados no banco de dados como um hash unidirecional.
            Bcrypt possui uma implementação de helpers para fazer o hash e verificação de passwords.

            Instalando Bcrypt:
                $ go get golang.org/x/crypto/bcrypt@latest

            A função abaixo
                hash, err := bcrypt.GenerateFromPassword([]byte("my plain text password"), 12)
            retorna um hash de 60 caracters, parecido com isso
                $2a$12$NuTjWXm3KKntReFwyBVHyuf/to.HEwTy.eS206TNfkGfr6HzGJSWG
            
            O segundo parâmetro indica o custo, ele é representado por um inteiro de 4 a 31.
            O exemplo acima usa custo 12, ou seja, 2^12(4096) iterações do brcypt foram usadas para gerar o hash.

            A função abaixo
                hash := []byte("$2a$12$NuTjWXm3KKntReFwyBVHyuf/to.HEwTy.eS206TNfkGfr6GzGJSWG")
                err := bcrypt.CompareHashAndPassword(hash, []byte("my plain text password"))
            compara o password plain-text com um hash.
            Ela retorna nil se o plai-text password corresponde ao hash e um erro se eles não correspondem.
        
        Storing the user details
            Atualizar UserModel.Insert() para adicionar um novo usuário na tabela usando as informações
            fornecidas por userSignupPost() e password hasheado com bcrypt.
                
                - fazer o hash do password
                - gerenciar o potencial erro devido a constraint de e-mails duplicados
            
            Todos os erros do sql retornam um código particular: https://dev.mysql.com/doc/mysql-errors/8.0/en/
            No caso de e-mails duplicados o código é 1062 (ER_DUP_ENTRY).

            Atualizar o userSignupPost()
            Invocar app.users.Inser() passando os parameotros necessários.
            Lembrando que:
                main.go
                    type application struct {
                        snippets       *models.SnippetModel
                        users          *models.UserModel
                    }

                users.go
                    type UserModel struct {
                        DB *sql.DB
                    }

                    func (m *UserModel) Insert(name, email, password string) error {
                        // hash password
                        // create statement string with '?' wildcards
                        // insert with m.DB.Exec()
                        // verify for  database error 1062 (ER_DUP_ENTRY)
                        // return nil means user created with success
                    }

            Além disso, adicionar uma flash message que será exibida quando o usuário se cadastrar.
                app.sessionManager.Put(r.Context(), "flash", "Your signup was successful. Please log in.")
        
        Additional information

            Alternatives for checking email duplicates
                O código de UserModel.Insert() não é muito bonito pois faz comparações e se baseia
                em código/string de erro retornado pelo MySQL.
                E se uma nova versão do MySQL for lançada com uma alteração na mensagem/codigo de erro?

                Outra opção para validar o e-mail seria criar um método UserModel.EmailTaken() para verificar
                se o e-mail já está em uso antes do usuário ser inserido no banco de dados.

                A última opção gera uma 'race condition' que é quase impossível de acontecer.
                Se dois usuários tentarem se cadastrar usando o mesmo e-mail exatamente no mesmo momento.
                As duas submissões passarão pela validação, mas apenas um INSERT ocorrerá no banco de dados.
    
    11.4 User login

        Criar o corpo do método Authenticate() em users.go.
            - recuperar o usuário do DB com QueryRow() usando a coluna e-mail no WHERE
            - comparar o password passado como parametro com o hashed_password recuperado do DB: bcrypt.CompareHashAndPassword(hashedPassword, []byte(password))
            - retornar o id do usuário em casos de sucesso
            - retornar 0 e um erro associado quando o usuário não for encontrado
        
        Atualizar validator.go para suportar erros que não estão associados a um campo específico de formulário.

            type Validator struct {
                NonFieldErrors []string
                FieldErrors    map[string]string
            }

            func (v *Validator) Valid() bool {
                return len(v.FieldErrors) == 0 && len(v.NonFieldErrors) == 0
            }

            func (v *Validator) AddNonFieldError(message string) {
                v.NonFieldErrors = append(v.NonFieldErrors, message)
            }
        
        Criar um template de login chamado login.tmpl.
        
        Ajustar o handler handlers.go para exibir a pagina de login:
            - criar uma struct userLoginForm para representar o formulário de login(email e senha)
            - construir o corpo do handler userLogin() para que login.tmpl seja exibido
            - construir o corpo do handler userLoginPost() para que o usuário consiga logar

    11.5 User logout
        A implementação do logout é bem direta, basicamente é preciso remover "authenticatedUserID" da sessão.
        Ao mesmo tempo que é uma boa pratica renovar o ID da sessão quando ocorre uma mudança de privilegios
        também é importante exibit uma flash message confirmando o logout.
        
        Atualizar o handler userLogoutPost.
            - renovar o ID da sessão porque ocorrerá uma mudança de privilégios
                app.sessionManager.RenewToken(r.Context())
            
            - remover o authenticatedUserID da sessão.
                app.sessionManager.Remove(r.Context(), "authenticatedUserID"
            
            - adicionar a flash message confirmando logout
            - redirecionar para a home que exibirá a flash message com popString().
