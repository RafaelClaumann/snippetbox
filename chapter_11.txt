Chapter 11 User authentication
    
    Adicionar autenticação a aplicação:
        - Apenas usuários registrados e logados conseguirão criar snippets.
        - Usuários não logados conseguirão ver os snippets.
        - Usuários não registrados conseguirão se registrar.
    
    Passo a passo:
        - Usuários poderão se registrar em '/user/signup' com nome, email e senha.
          Uma nova tabela(users) será criada para armazenar os usuários.

        - Usuários farão o login em '/user/login' com email e senha.
    
        - Verificar se usuário e senha são compatíveis com os valores recuperados do banco de dados.
          Se forem compatíveis, o usuário será autenticado e a chave 'authenticatedUserID' será adicionada ao 'session data'.

        - As requisições subsequentes serão verificadas através da chave 'authenticatedUserID'.
          Se 'authenticatedUserID' existir, significa que o usuário logou com sucesso, essa chave será monitorada a sessão expirar.
          Se 'authenticatedUserID' não existir, significa que o usuário não está autenticado.

    11.1 Routes setup

            GET     /user/signup    userSignup      Display a HTML form for signing up a new user
            POST    /user/signup    userSignupPost  Create a new user
            GET     /user/login     userLogin       Display a HTML form for logging in a user
            POST    /user/login     userLoginPost   Authenticate and login the user
            POST    /user/logout    userLogoutPost  Logout the user

        Adicionar a pre-implementação das novas rotas no arquivo handlers.go.

            func (app *application) userSignup(w http.ResponseWriter, r *http.Request)
            func (app *application) userSignupPost(w http.ResponseWriter, r *http.Request)
            func (app *application) userLogin(w http.ResponseWriter, r *http.Request)
            func (app *application) userLoginPost(w http.ResponseWriter, r *http.Request)
            func (app *application) userLogoutPost(w http.ResponseWriter, r *http.Request)

        Configurar as os handlers em routers.go.
            router.Handler(http.MethodGet, "/user/signup", dynamic.ThenFunc(app.userSignup))
            router.Handler(http.MethodPost, "/user/signup", dynamic.ThenFunc(app.userSignupPost))
            router.Handler(http.MethodGet, "/user/login", dynamic.ThenFunc(app.userLogin))
            router.Handler(http.MethodPost, "/user/login", dynamic.ThenFunc(app.userLoginPost))
            router.Handler(http.MethodPost, "/user/logout", dynamic.ThenFunc(app.userLogoutPost))

        Atualizar o nav.tmpl com uma nova <div> para exibir os botões Singup, Login e Logout':
                <div>
                    <a href='/user/signup'>Signup</a>
                    <a href='/user/login'>Login</a>
                    <form action='/user/logout' method='POST'>
                        <button>Logout</button>
                    </form>
                </div>
    
    11.2 Creating a users model

        Criar a tabela no banco de dados e o modelo(repository) para acessa-la.

                USE snippetbox;

                CREATE TABLE users (
                    id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
                    name VARCHAR(255) NOT NULL,
                    email VARCHAR(255) NOT NULL,
                    hashed_password CHAR(60) NOT NULL,
                    created DATETIME NOT NULL
                );

                ALTER TABLE users ADD CONSTRAINT users_uc_email UNIQUE (email);
            
            A constraint users_uc_email garante que não existirão dois usuários com o mesmo e-mail.
    
        Building the model in Go
            Definir novos erros no arquivo models/errors.go.
                var ErrInvalidCredentials = errors.New("models: invalid credentials")
                var ErrDuplicateEmail = errors.New("models: duplicate email")
            
            Criar um novo arquivo models/users.go.
            
            Adicionar um campo users do tipo *models.UserModel na struct application em main.go.

    11.3 User signup and password encryption

        É preciso permitir que os usuários registrem suas contas(singup).
        Criar um novo arquivo ui/html/pages/signup.tmpl.
        Inserir a struct userSignupForm em handlers.go e atualizar o handler userSignup para que signup.tmpl seja exibido.

            templates.go
                type templateData struct {
                    Form        any
                }

            helpers.go
                func (app *application) newTemplateData(r *http.Request) *templateData {
                    return &templateData{
                        CurrentYear: time.Now().Year(),
                    }
                }

            validator.go 
                type Validator struct {
                    FieldErrors map[string]string
                }

            handlers.go
                type userSignupForm struct {
                    validator.Validator
                }

                func (app *application) userSignup(w http.ResponseWriter, r *http.Request) {
                    data := app.newTemplateData(r)
                    data.Form = userSignupForm{}

                    app.render(w, http.StatusOK, "signup.tmpl", data)
                }

            A chamada a app.newTemplateData(r) cria um novo templateData e o armazena na variável data.
            O campo Form deste template data recebe um 'userSignupForm'.
            O 'userSignupForm' encorpora(embed) a struct 'Validator' que contém o campo 'FieldErrors'.
            É possível acessar 'FieldErrors' a partir de 'userSignupForm': data.Form.FieldErrors.
            O template signup.tmpl recebe 'userSignupForm' e por isso consegue acessar data.Form.FieldErrors.
    
        Validating the user input
            Os dados submetidos em signup.tmpl serão processados no handler userSignupPost.
            É preciso validar os dados para garantir que são 'sane' antes de inseri-los no banco de dados.
                1 - Garantir que name, email e password não são blank
                2 - 'Sanity' check no formato do email
                3 - Garantir que o password tenha mais do que 8 caracteres
                4 - Certifique-se de que o endereço de e-mail ainda não esteja em uso
            
            Criar dois novos validadores e uma regex para e-mails em Validator.go.
                - MinChars()
                - Matches()
                - var EmailRX = regexp.MustCompile(...)
            
                A regex usada é recomendada pela W3C e Web Hypertext Application Technology Working Group.
                https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
                https://www.w3.org/TR/2016/REC-html51-20161101/sec-forms.html#email-state-typeemail
            
            Adicionar código em userSignupPost para processar os dados do form.

            Tudo que restou foi validar que o e-mail inserido no formulário ainda não está em uso.
            A constraint UNIQUE na coluna email da tabela users garante que o mesmo email não será usado mais de uma vez.
            Do ponto de vista da regra de negócio e integridade de dados está tudo OK.
            Mas, o problema é, como comunicar para o cliente que o e-mail já está em uso?
            Isto será resolvido no final do capitulo

        A brief introduction to bcrypt
            É uma desejavel que os passwords armazenados no banco de dados como um hash unidirecional.
            Bcrypt possui uma implementação de helpers para fazer o hash e verificação de passwords.

            Instalando Bcrypt:
                $ go get golang.org/x/crypto/bcrypt@latest

            A função abaixo
                hash, err := bcrypt.GenerateFromPassword([]byte("my plain text password"), 12)
            retorna um hash de 60 caracters, parecido com isso
                $2a$12$NuTjWXm3KKntReFwyBVHyuf/to.HEwTy.eS206TNfkGfr6HzGJSWG
            
            O segundo parâmetro indica o custo, ele é representado por um inteiro de 4 a 31.
            O exemplo acima usa custo 12, ou seja, 2^12(4096) iterações do brcypt foram usadas para gerar o hash.

            A função abaixo
                hash := []byte("$2a$12$NuTjWXm3KKntReFwyBVHyuf/to.HEwTy.eS206TNfkGfr6GzGJSWG")
                err := bcrypt.CompareHashAndPassword(hash, []byte("my plain text password"))
            compara o password plain-text com um hash.
            Ela retorna nil se o plai-text password corresponde ao hash e um erro se eles não correspondem.
        
        Storing the user details
            Atualizar UserModel.Insert() para adicionar um novo usuário na tabela usando as informações
            fornecidas por userSignupPost() e password hasheado com bcrypt.
                
                - fazer o hash do password
                - gerenciar o potencial erro devido a constraint de e-mails duplicados
            
            Todos os erros do sql retornam um código particular: https://dev.mysql.com/doc/mysql-errors/8.0/en/
            No caso de e-mails duplicados o código é 1062 (ER_DUP_ENTRY).

            Atualizar o userSignupPost()
            Invocar app.users.Inser() passando os parameotros necessários.
            Lembrando que:
                main.go
                    type application struct {
                        snippets       *models.SnippetModel
                        users          *models.UserModel
                    }

                users.go
                    type UserModel struct {
                        DB *sql.DB
                    }

                    func (m *UserModel) Insert(name, email, password string) error {
                        // hash password
                        // create statement string with '?' wildcards
                        // insert with m.DB.Exec()
                        // verify for  database error 1062 (ER_DUP_ENTRY)
                        // return nil means user created with success
                    }

            Além disso, adicionar uma flash message que será exibida quando o usuário se cadastrar.
                app.sessionManager.Put(r.Context(), "flash", "Your signup was successful. Please log in.")
        
        Additional information

            Alternatives for checking email duplicates
                O código de UserModel.Insert() não é muito bonito pois faz comparações e se baseia
                em código/string de erro retornado pelo MySQL.
                E se uma nova versão do MySQL for lançada com uma alteração na mensagem/codigo de erro?

                Outra opção para validar o e-mail seria criar um método UserModel.EmailTaken() para verificar
                se o e-mail já está em uso antes do usuário ser inserido no banco de dados.

                A última opção gera uma 'race condition' que é quase impossível de acontecer.
                Se dois usuários tentarem se cadastrar usando o mesmo e-mail exatamente no mesmo momento.
                As duas submissões passarão pela validação, mas apenas um INSERT ocorrerá no banco de dados.
    
    11.4 User login

        Criar o corpo do método Authenticate() em users.go.
            - recuperar o usuário do DB com QueryRow() usando a coluna e-mail no WHERE
            - comparar o password passado como parametro com o hashed_password recuperado do DB: bcrypt.CompareHashAndPassword(hashedPassword, []byte(password))
            - retornar o id do usuário em casos de sucesso
            - retornar 0 e um erro associado quando o usuário não for encontrado
        
        Atualizar validator.go para suportar erros que não estão associados a um campo específico de formulário.

            type Validator struct {
                NonFieldErrors []string
                FieldErrors    map[string]string
            }

            func (v *Validator) Valid() bool {
                return len(v.FieldErrors) == 0 && len(v.NonFieldErrors) == 0
            }

            func (v *Validator) AddNonFieldError(message string) {
                v.NonFieldErrors = append(v.NonFieldErrors, message)
            }
        
        Criar um template de login chamado login.tmpl.
        
        Ajustar o handler handlers.go para exibir a pagina de login:
            - criar uma struct userLoginForm para representar o formulário de login(email e senha)
            - construir o corpo do handler userLogin() para que login.tmpl seja exibido
            - construir o corpo do handler userLoginPost() para que o usuário consiga logar

    11.5 User logout
        A implementação do logout é bem direta, basicamente é preciso remover "authenticatedUserID" da sessão.
        Ao mesmo tempo que é uma boa pratica renovar o ID da sessão quando ocorre uma mudança de privilegios
        também é importante exibit uma flash message confirmando o logout.
        
        Atualizar o handler userLogoutPost.
            - renovar o ID da sessão porque ocorrerá uma mudança de privilégios
                app.sessionManager.RenewToken(r.Context())
            
            - remover o authenticatedUserID da sessão.
                app.sessionManager.Remove(r.Context(), "authenticatedUserID"
            
            - adicionar a flash message confirmando logout
            - redirecionar para a home que exibirá a flash message com popString().
    
    11.6 User authorization

        É preciso fazer algo útil a autenticação criada na sessão passadas, aplicaremos autorização aos usuários.
        
            - Apenas usuários autenticados conseguirão criar novos snippets
            - O conteúdo do nav-bar será diferente quando o usuário estiver autenticado ou não
                - Usuario autenticado -> Home, Create Snippet e Logout
                - Usuario nao autenticado -> Home, Signup e Login

            Se o usuário estiver autenticado o atributo "authenticatedUserID" existirá na sessão.
            
            Criar um método isAuthenticated() em helpers.go para verificar se o usuário está autenticado.

                // Return true if the current request is from an authenticated user, otherwise
                // return false.
                func (app *application) isAuthenticated(r *http.Request) bool {
                    return app.sessionManager.Exists(r.Context(), "authenticatedUserID")
                }

            Passar a informação de autenticação para os templates de forma que consigam ocultar/exibir os menus do nav-bar.

                Adicionar um campo bool chamado IsAuthenticated ao templateData em templates.go.
                
                    type templateData struct {
                        ...
                        IsAuthenticated bool   // Add an IsAuthenticated field to the templateData struct.
                    }
                
                Atualizar newTemplateData() em helpers.go para que essa informação(IsAuthenticated) seja
                adicionada ao templateData toda vez que um template for renderizado.

                    // Add the authentication status to the template data.
                    func (app *application) newTemplateData(r *http.Request) *templateData {
                        return &templateData{
                            ...
                            IsAuthenticated: app.isAuthenticated(r),
                        }
                    }
                
                Atualizar o ui/html/partials/nav.tmpl para exibir os menus de acordo com a autenticação.

                    {{if .IsAuthenticated}}
                        <a href='/snippet/create'>Create snippet</a>
                    {{end}}
        
        Restricting access

            Usuários não autenticados ainda conseguem acessar '/snippet/create' diretamente.
            Ajustar para quando um usuário não autenticado acessar '/snippet/create' ou '/user/logout' seja redirecionado para '/user/login'.

            A maneira mais fácil de fazer isso é através de middlewares.
            Criar o middlware requireAuthentication() em middlewares.go.

            Reorganizar as rotas em dois grupos:
                - desprotegido, com as rotas que não precisam de proteção, usarão a cadeia 'dynamic' que já existe
                - protected, consiste na cadeia 'dynamic' com o novo middeware requireAuthentication() adicionado
            
        Additional information
            
            Without using alice
                router.Handler(
                    http.MethodPost,
                    "/snippet/create",
                    app.sessionManager.LoadAndSave(
                        app.requireAuthentication(
                            http.HandlerFunc(
                                app.snippetCreate
                            )
                        )
                    )
                )

    11.7 CSRF protection

        Como proteger o site contra Cross-Site Request Forgery
            https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html
        
        É um ataque onde um sitem malicioso envia uma requisições HTTP capazes de alterar o estado para o seu website.

        - Usuario faz login na aplicação Snippetbox. O cookie de sessão está configurado para persistir por 12 horas.
        - O usuário navega até um site malicioso que contém código para realizar uma cross-site request em POST '/snippet/create'.
          O cookie da sessão será enviado junto com esta requisição.
        - Como a requisição contém o cookie do usuário a aplicação Snippetbox interpreta que ela foi enviada por um usuário logado.
          A consequencia disto é que um novo snippet sem que o usuário saiba.
        
        SameSite cookies            
            Ao definir o atributo SameSite como SameSite=Lax.
            
            O cookie de sessão não será enviado pelo browser do usuário em requisições unsafe(POST, PUT ou DELETE) entre sites.
            
            Snippetbox usa POST para alterar o estado da aplicação e POST é considerado 'unsafe' o cookie de sessão não será enviado
            nessas requisições se elas forem cross-site.

            O atributo SameSite é relativamente novo e é suportado por 90% dos browsers.
            

            SameSite owasp:
                https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#samesite-cookie-attribute

            O que é unsafe:
                https://datatracker.ietf.org/doc/html/rfc7231#section-4.2.1
            
        Token-based mitigation
            Já existem pacotes que implementam este tipo de mitigação e é melhor utiliza-los do que criar sua própria lógica
            e correr riscos desnecessários.

            Os pacotes 'gorilla/csrf' e 'justinas/nosurf' são recomendados.
            Ambos fazem mais ou menos a mesma coisa usando o padrão 'double-submit cookie' para previnir ataques.

            Um token CSRF aleatório é gerado e enviado para o usuário em um Cookie CSRF.
            Este token CSRF é adicionado a um campo oculto em cada formulário HTML vulnerável a CSRF.
            Quando o formulário é submetido ambos pacotes usam algum middleware para verificar se o campo oculto e o cookie correspondem.
        
            Vamos usar Justinas Nosurf:
                go get github.com/justinas/nosurf@v1

            Token-based mitigation owasp:
                https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#token-based-mitigation
            
            Gorilla CSRF:
                https://github.com/gorilla/csrf
            
            Justinas Nosurf:
                https://github.com/justinas/nosurf

            double-submit cookie owasp:
                https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#double-submit-cookie
        
        Using the nosurf package

            Criar um middleware chamado noSurf() em middleware.go.

                func noSurf(next http.Handler) http.Handler {
                    csrfHandler := nosurf.New(next)
                    csrfHandler.SetBaseCookie(http.Cookie{
                        HttpOnly: true,
                        Path:     "/",
                        Secure:   true,
                    })

                    return csrfHandler
                }
            
            Um dos formulários que precisa se protegido é o de logout(escrito errado no livro? nao seria login?).
            Ele está incluído em nav.tmpl e potencialmente pode em todas as páginas da aplicação.
            Por conta disso precisamos aplicar o middlware noSurf() em todas as rotas exceto 'static/*filepath'.

            Atualizar routes.go e adicionar o middleware noSurf() na cadeia dynamic.
                
                dynamic := alice.New(app.sessionManager.LoadAndSave, noSurf)
            
            Neste momento a aplicação responderá 400 BAD Request para qualquer form enviado.
            Para que volte a funcionar é preciso obter o token com nosurf.Token() e adiciona-lo ao campo csrf_token
            em todos os formulários.

            Adicionar o campo CSRFToken no templateData para que possa ser acessado em todos os templates.
            Inicializar o campo CSRFToken no helper newTemplateData():

                func (app *application) newTemplateData(r *http.Request) *templateData {
                    return &templateData{
                        ...
                        CSRFToken:       nosurf.Token(r),        // Add the CSRF token.
                    }
                }
            
            Atualizar todos os formulários para incluir o CSRF Token com campo oculto.
