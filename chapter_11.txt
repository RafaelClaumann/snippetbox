Chapter 11 User authentication
    
    Adicionar autenticação a aplicação:
        - Apenas usuários registrados e logados conseguirão criar snippets.
        - Usuários não logados conseguirão ver os snippets.
        - Usuários não registrados conseguirão se registrar.
    
    Passo a passo:
        - Usuários poderão se registrar em '/user/signup' com nome, email e senha.
          Uma nova tabela(users) será criada para armazenar os usuários.

        - Usuários farão o login em '/user/login' com email e senha.
    
        - Verificar se usuário e senha são compatíveis com os valores recuperados do banco de dados.
          Se forem compatíveis, o usuário será autenticado e a chave 'authenticatedUserID' será adicionada ao 'session data'.

        - As requisições subsequentes serão verificadas através da chave 'authenticatedUserID'.
          Se 'authenticatedUserID' existir, significa que o usuário logou com sucesso, essa chave será monitorada a sessão expirar.
          Se 'authenticatedUserID' não existir, significa que o usuário não está autenticado.

    11.1 Routes setup

            GET     /user/signup    userSignup      Display a HTML form for signing up a new user
            POST    /user/signup    userSignupPost  Create a new user
            GET     /user/login     userLogin       Display a HTML form for logging in a user
            POST    /user/login     userLoginPost   Authenticate and login the user
            POST    /user/logout    userLogoutPost  Logout the user

        Adicionar a pre-implementação das novas rotas no arquivo handlers.go.

            func (app *application) userSignup(w http.ResponseWriter, r *http.Request)
            func (app *application) userSignupPost(w http.ResponseWriter, r *http.Request)
            func (app *application) userLogin(w http.ResponseWriter, r *http.Request)
            func (app *application) userLoginPost(w http.ResponseWriter, r *http.Request)
            func (app *application) userLogoutPost(w http.ResponseWriter, r *http.Request)

        Configurar as os handlers em routers.go.
            router.Handler(http.MethodGet, "/user/signup", dynamic.ThenFunc(app.userSignup))
            router.Handler(http.MethodPost, "/user/signup", dynamic.ThenFunc(app.userSignupPost))
            router.Handler(http.MethodGet, "/user/login", dynamic.ThenFunc(app.userLogin))
            router.Handler(http.MethodPost, "/user/login", dynamic.ThenFunc(app.userLoginPost))
            router.Handler(http.MethodPost, "/user/logout", dynamic.ThenFunc(app.userLogoutPost))

        Atualizar o nav.tmpl com uma nova <div> para exibir os botões Singup, Login e Logout':
                <div>
                    <a href='/user/signup'>Signup</a>
                    <a href='/user/login'>Login</a>
                    <form action='/user/logout' method='POST'>
                        <button>Logout</button>
                    </form>
                </div>
    
    11.2 Creating a users model

        Criar a tabela no banco de dados e o modelo(repository) para acessa-la.

                USE snippetbox;

                CREATE TABLE users (
                    id INTEGER NOT NULL PRIMARY KEY AUTO_INCREMENT,
                    name VARCHAR(255) NOT NULL,
                    email VARCHAR(255) NOT NULL,
                    hashed_password CHAR(60) NOT NULL,
                    created DATETIME NOT NULL
                );

                ALTER TABLE users ADD CONSTRAINT users_uc_email UNIQUE (email);
            
            A constraint users_uc_email garante que não existirão dois usuários com o mesmo e-mail.
    
        Building the model in Go
            Definir novos erros no arquivo models/errors.go.
                var ErrInvalidCredentials = errors.New("models: invalid credentials")
                var ErrDuplicateEmail = errors.New("models: duplicate email")
            
            Criar um novo arquivo models/users.go.
            
            Adicionar um campo users do tipo *models.UserModel na struct application em main.go.

    11.3 User signup and password encryption

        É preciso permitir que os usuários registrem suas contas(singup).
        Criar um novo arquivo ui/html/pages/signup.tmpl.
        Inserir a struct userSignupForm em handlers.go e atualizar o handler userSignup para que signup.tmpl seja exibido.

            templates.go
                type templateData struct {
                    Form        any
                }

            helpers.go
                func (app *application) newTemplateData(r *http.Request) *templateData {
                    return &templateData{
                        CurrentYear: time.Now().Year(),
                    }
                }

            validator.go 
                type Validator struct {
                    FieldErrors map[string]string
                }

            handlers.go
                type userSignupForm struct {
                    validator.Validator
                }

                func (app *application) userSignup(w http.ResponseWriter, r *http.Request) {
                    data := app.newTemplateData(r)
                    data.Form = userSignupForm{}

                    app.render(w, http.StatusOK, "signup.tmpl", data)
                }

            A chamada a app.newTemplateData(r) cria um novo templateData e o armazena na variável data.
            O campo Form deste template data recebe um 'userSignupForm'.
            O 'userSignupForm' encorpora(embed) a struct 'Validator' que contém o campo 'FieldErrors'.
            É possível acessar 'FieldErrors' a partir de 'userSignupForm': data.Form.FieldErrors.
            O template signup.tmpl recebe 'userSignupForm' e por isso consegue acessar data.Form.FieldErrors.
    
        Validating the user input
            Os dados submetidos em signup.tmpl serão processados no handler userSignupPost.
            É preciso validar os dados para garantir que são 'sane' antes de inseri-los no banco de dados.
                1 - Garantir que name, email e password não são blank
                2 - 'Sanity' check no formato do email
                3 - Garantir que o password tenha mais do que 8 caracteres
                4 - Certifique-se de que o endereço de e-mail ainda não esteja em uso
            
            Criar dois novos validadores e uma regex para e-mails em Validator.go.
                - MinChars()
                - Matches()
                - var EmailRX = regexp.MustCompile(...)
            
                A regex usada é recomendada pela W3C e Web Hypertext Application Technology Working Group.
                https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address
                https://www.w3.org/TR/2016/REC-html51-20161101/sec-forms.html#email-state-typeemail
            
            Adicionar código em userSignupPost para processar os dados do form.

            Tudo que restou foi validar que o e-mail inserido no formulário ainda não está em uso.
            A constraint UNIQUE na coluna email da tabela users garante que o mesmo email não será usado mais de uma vez.
            Do ponto de vista da regra de negócio e integridade de dados está tudo OK.
            Mas, o problema é, como comunicar para o cliente que o e-mail já está em uso?
            Isto será resolvido no final do capitulo
